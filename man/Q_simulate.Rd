% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fstruct_functions.R
\name{Q_simulate}
\alias{Q_simulate}
\title{Simulate one or more Q matrices using the Dirichlet distribution}
\usage{
Q_simulate(alpha, lambda, rep, popsize, seed)
}
\arguments{
\item{alpha}{A number that sets the variability of the membership coefficients. The variance of coefficient k is Var[x_k] = \eqn{\lambda_k/(\alpha+1)}. Larger values of \eqn{\alpha} lead to lower variability.}

\item{lambda}{A vector that sets the mean membership of each ancestral cluster across the population. The vector should sum to 1.}

\item{rep}{The number of Q matrices to generate.}

\item{popsize}{The number of individuals to include in each Q matrix.}

\item{seed}{Optional; sets the random seed. Use if reproducibility of random results is desired.}
}
\value{
A data frame containing the simulated Q matrices. Each row represents a single simulated individual. The data frame has the following columns
\itemize{
\item \code{rep}: Which random Q matrix the row belongs to (a number between 1 and the parameter \code{rep})
\item \code{ind}: Which individual in each Q matrix the row corresponds to (a number between 1 and the parameter \code{popsize})
\item \code{alpha}: The alpha value used to simulate the Q matrix.
\item \code{Pop}: alpha_rep (where alpha and rep are the columns described above). Serves as a unique identifier for each Q matrix (useful if running simulations with many different values of \eqn{\alpha}).
\item \code{lambda1, lambda2, etc.}: Membership coefficients (sum to 1).
}
}
\description{
Simulates Q matrices by drawing vectors of membership coefficients from a Dirichlet distrubtion parameterized by two variables: \eqn{\alpha}, which controls variability, and \eqn{\lambda=(\lambda_1, \lambda_2, ...., \lambda_K)} which controls the mean of each of the K ancestry coefficients.
}
\examples{
# Simulate 100 random Q matrices.
# Each Q matrix has 100 individuals.
# On average these individuals have mean ancestry (1/2, 1/4, 1/4)
# from each of 3 ancestral clusters.
# The variance of each cluster x_i is Var[x_i] = lambda_i/(alpha + 1)
# Here lambda_1 = 1/2, lambda_2 = lambda_3 = 1/4

Q_list <- Q_simulate(alpha = 1, lambda = c(1/2, 1/4, 1/4),
                    rep = 100, popsize = 50, seed = 1)

}
