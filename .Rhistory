df <- data.frame(cbind(data.frame(Individuals = 1:nrow(Q)), Q)) %>%
tidyr::pivot_longer(cols = 2:(ncol(Q) + 1))
df$name <- factor(df$name, levels = unique(df$name) %>% rev())
# Generate the structure plot
ggplot2::ggplot(
data = df,
ggplot2::aes(fill = .data$name, y = .data$value, x = .data$Individuals)
) +
ggplot2::geom_bar(position = "stack", stat = "identity", width = 1) +
ggplot2::scale_fill_brewer(palette = "Spectral") +
ggplot2::theme_void() +
ggplot2::ylab("") +
ggplot2::theme(legend.position = "none")
# Generate the structure plot
ggplot2::ggplot(
data = df,
ggplot2::aes(fill = .data$name, y = .data$value, x = .data$Individuals)
) +
ggplot2::geom_bar(position = "stack", stat = "identity", width = 1) +
# ggplot2::scale_fill_brewer(palette = "Spectral") +
ggplot2::theme_void() +
ggplot2::ylab("") +
ggplot2::theme(legend.position = "none")
Q <- data.frame(Q) %>%
dplyr::arrange(get(names(clustermeans))) %>%
dplyr::select(names(clustermeans) %>% rev)
# Generate the data to plot
df <- data.frame(cbind(data.frame(Individuals = 1:nrow(Q)), Q)) %>%
tidyr::pivot_longer(cols = 2:(ncol(Q) + 1))
df$name <- factor(df$name, levels = unique(df$name) %>% rev())
# Generate the structure plot
ggplot2::ggplot(
data = df,
ggplot2::aes(fill = .data$name, y = .data$value, x = .data$Individuals)
) +
ggplot2::geom_bar(position = "stack", stat = "identity", width = 1) +
# ggplot2::scale_fill_brewer(palette = "Spectral") +
ggplot2::theme_void() +
ggplot2::ylab("") +
ggplot2::theme(legend.position = "none")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.6,.3,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.6,.3,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = FALSE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.6,.3,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = FALSE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
# ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
devtools::load_all
rm(Q_plot)
devtools::load_all()
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.6,.3,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = FALSE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
# ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = FALSE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
# ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
# ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE)
Q
K=3
Q_checker(Q = Q, K = K)
clustermeans <- colMeans(Q) %>% sort() %>% rev
clustermeans
names(clustermeans)
A = Q_simulate(alpha = .1,
lambda = c(.5, .5),
rep = 1,
popsize = 20,
seed = 1)
A
paste0("q",1:K)
# Check if Q matrix is within a list, and extract if needed
if (is.list(Q) && !is.data.frame(Q) && !is.array(Q)) {
Q <- Q[[1]]
}
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if (ncol(Q) > K) {
Q <- Q[, (ncol(Q) - K + 1):ncol(Q)]
}
# convert Q matrix entries to numbers
Q <- data.matrix(Q)
colnames(Q) <- paste0("q",1:K)
Q
library(devtools)
build()
check()
install.packages("qpdf")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
# ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
Q_checker(Q, 3)
alpha = .1
lambda = c(.5, .5)
rep = 1
popsize = 20
# How many clusters are there?
K <- length(lambda)
K
if (!missing(seed)) {
set.seed(seed)
}
alpha %>%
data.frame("alpha" = .)
alpha %>%
data.frame("alpha" = .) %>%
cbind(apply(X = ., MARGIN = 1, FUN = function(a) a * lambda)
apply(X = ., MARGIN = 1, FUN = function(a) a * lambda) %>%
matrix(byrow = TRUE, ncol = K)
alpha %>%
data.frame("alpha" = .) %>%
cbind(apply(X = ., MARGIN = 1, FUN = function(a) a * lambda) %>%
matrix(byrow = TRUE, ncol = K))
alpha %>%
data.frame("alpha" = .) %>%
cbind(apply(X = ., MARGIN = 1, FUN = function(a) a * lambda) %>%
matrix(byrow = TRUE, ncol = K)) %>%
# this step necessary for K=1 case
`colnames<-`(c("alpha", sapply(1:K, function(k) paste0("a", k))))
# (a1, a2, ...) = (lambda1, lambda2, ...)*alpha parameterizes the Dirichlet distribution
alpha_vec <- alpha %>%
data.frame("alpha" = .) %>%
cbind(apply(X = ., MARGIN = 1, FUN = function(a) a * lambda) %>%
matrix(byrow = TRUE, ncol = K)) %>%
# this step necessary for K=1 case
`colnames<-`(c("alpha", sapply(1:K, function(k) paste0("a", k))))
#' ) +
#'   # Below are example, optional modifications to the default plot
#'   ggplot2::ggtitle("Population A") +
#'   ggplot2::scale_fill_brewer("Blues") +
#'   ggplot2::xlab("Individuals")
#' @importFrom dplyr %>%
#' @importFrom dplyr arrange
#' @importFrom dplyr select
#' @importFrom rlang .data
#' @export
Q_plot <- function(Q, K, arrange) {
# Clean the matrices for plotting:
Q <- Q_checker(Q = Q, K = K)
# Generate the data to plot
df <- data.frame(cbind(data.frame(Individuals = 1:nrow(Q)), Q)) %>%
tidyr::pivot_longer(cols = 2:(ncol(Q) + 1))
df$name <- factor(df$name, levels = unique(df$name) %>% rev())
# Re-order individuals if arrange == TRUE
if (!missing(arrange)) {
if(arrange == TRUE){
clustermeans <- colMeans(Q) %>% sort() %>% rev
Q <- data.frame(Q) %>%
dplyr::arrange(get(names(clustermeans))) %>%
dplyr::select(names(clustermeans))
}
} # MAIKE TO DO: NEED TO RE ORDER COLORS TO MATCH SORTING
# Generate the data to plot
df <- data.frame(cbind(data.frame(Individuals = 1:nrow(Q)), Q)) %>%
tidyr::pivot_longer(cols = 2:(ncol(Q) + 1))
df$name <- factor(df$name, levels = unique(df$name) %>% rev())
# Generate the structure plot
ggplot2::ggplot(
data = df,
ggplot2::aes(fill = .data$name, y = .data$value, x = .data$Individuals)
) +
ggplot2::geom_bar(position = "stack", stat = "identity", width = 1) +
ggplot2::theme_void() +
ggplot2::ylab("") +
ggplot2::theme(legend.position = "none")
}
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
rm(Q_plot)
load_all()
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
check()
Q_plot(
# Make an example matrix of membership coefficients.
# Each row is an individual. Rows sum to 1.
Q = matrix(c(.4,.2,.4,
.5,.3,.2,
.5,.4,.1,
.6,.1,.3,
.3,.6,.1),
nrow = 5,
byrow = TRUE),
K = 3, # How many ancestry coefficients per individual?
arrange = TRUE
) +
# Below are example, optional modifications to the default plot
ggplot2::ggtitle("Population A") +
ggplot2::scale_fill_brewer("Blues") +
ggplot2::xlab("Individuals")
A = Q_simulate(alpha = .1,
lambda = c(.5, .5),
rep = 1,
popsize = 20,
seed = 1)
B = Q_simulate(alpha = .1,
lambda = c(.5, .5),
rep = 1,
popsize = 20,
seed = 2)
C = Q_simulate(alpha = 1,
lambda = c(.5, .5),
rep = 1,
popsize = 20,
seed = 3)
D = Q_simulate(alpha = 1,
lambda = c(.5, .5),
rep = 1,
popsize = 20,
seed = 4)
matrices = list(A=A,
B=B,
C=C,
D=D)
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1), K=3, arrange = TRUE)
Q_plot(A,2)
Q_plot(A,2, FALSE)
Q_plot(A,2, TRUE)
Q_plot(B,2, TRUE)
Q_plot(C,2, TRUE)
Q_plot(D,2, TRUE)
Q_plot(D,2, FALSE)
Q_plot(D,2)
# (a1, a2, ...) = (lambda1, lambda2, ...)*alpha parameterizes the Dirichlet distribution
alpha_vec <- alpha %>%
data.frame("alpha" = .) %>%
cbind(apply(X = ., MARGIN = 1, FUN = function(a) a * lambda) %>%
matrix(byrow = TRUE, ncol = K)) %>%
# this step necessary for K=1 case
`colnames<-`(c("alpha", sapply(1:K, function(k) paste0("a", k))))
# Generate a data frame that uses the alpha_vec matrix above to simulate ancestry coefficients for a population of individuals for each alpha
Q <- apply(
X = alpha_vec %>%
dplyr::select(-alpha), # Input is list of alpha vectors for each alpha
MARGIN = 1, # call function on each row
FUN = function(a) { # Draw ancestry vectors for a population for each alpha
gtools::rdirichlet(
n = popsize,
alpha = a
) %>%
round(10)
}
) %>%
data.frame() %>%
### Restructure output so the columns are: individual, alphas, lambda1, lambda2, rep
`colnames<-`(alpha_vec$alpha) %>%
dplyr::mutate(
ind = rep(1:popsize, K),
lambda = (sapply(
X = 1:K,
FUN = function(x) paste0("lambda", x)
) %>%
lapply(function(lambda) rep(lambda, popsize)) %>%
unlist())
) %>%
tidyr::pivot_longer(
cols = 1:length(alpha),
names_to = "alpha",
values_to = "Q"
) %>%
tidyr::pivot_wider(
names_from = lambda,
values_from = Q
) %>%
cbind("rep" = 1, .)
Q
# Generate a data frame that uses the alpha_vec matrix above to simulate ancestry coefficients for a population of individuals for each alpha
Q <- apply(
X = alpha_vec %>%
dplyr::select(-alpha), # Input is list of alpha vectors for each alpha
MARGIN = 1, # call function on each row
FUN = function(a) { # Draw ancestry vectors for a population for each alpha
gtools::rdirichlet(
n = popsize,
alpha = a
) %>%
round(10)
}
) %>%
data.frame() %>%
### Restructure output so the columns are: individual, alphas, lambda1, lambda2, rep
`colnames<-`(alpha_vec$alpha) %>%
dplyr::mutate(
ind = rep(1:popsize, K),
lambda = (sapply(
X = 1:K,
FUN = function(x) paste0("q", x)
) %>%
lapply(function(q) rep(q, popsize)) %>%
unlist())
) %>%
tidyr::pivot_longer(
cols = 1:length(alpha),
names_to = "alpha",
values_to = "Q"
) %>%
tidyr::pivot_wider(
names_from = lambda,
values_from = Q
) %>%
cbind("rep" = 1, .)
Q
load_all()
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1), K=3, arrange = TRUE)
Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 2)
load_all()
library(dplyr)
Q_example <- matrix(
c("1", "1", "(x)", "1", ":", "1", "0", "0",
"2", "2", "(x)", "1", ":", "1",  "0", "0",
"3", "3", "(x)", "2", ":", "0.0137", "0.7567", "0.2296",
"4", "4", "(x)", "2", ":", "0", "0.7325", "0.2674",
"5", "5", "(x)", "2", ":", "0.0224", "0.7279", "0.2496",
"6", "6", "(x)", "3", ":", "0.0222", "0.7372", "0.2406",
"7", "7", "(x)", "3", ":", "0", "0.7396", "0.2603",
"8", "8", "(x)", "3", ":", "0.0231", "0.7496", "0.2272",
"9", "9", "(x)", "3", ":", "0.046", "0.6861", "0.2678",
"10", "10", "(x)", "3", ":", "0.0843", "0.6739", "0.2418"),
ncol = 8,
byrow = TRUE
) %>%
data.frame %>%
mutate(X6 = as.numeric(X6),
X7 = as.numeric(X7))
A = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 1)
B = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 2)
C = Q_simulate(alpha = 1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 3)
D = Q_simulate(alpha = 1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 4)
plot_A <- Q_plot(Q = A %>% arrange(q1),
K=2) +
ggplot2::scale_fill_brewer("Blues")
plot_B <- Q_plot(Q = B,
K=2,
arrange = TRUE) +
ggplot2::scale_fill_brewer("Blues")
plot_C <- Q_plot(Q = C,
K=2,
arrange = TRUE) +
ggplot2::scale_fill_brewer("Blues")
plot_D <- Q_plot(Q = D,
K=2,
arrange = TRUE) +
ggplot2::scale_fill_brewer("Blues")
# Display these plots in a grid
cowplot::plot_grid(plot_A, plot_B, plot_C, plot_D,
labels = "AUTO",
nrow = 1,
vjust = 2)
Q_stat(Q = A, K = 2)
Q_stat(Q = B, K = 2)
Q_stat(Q = C, K = 2)
Q_stat(Q = D, K = 2)
build_all()
build()
install()
