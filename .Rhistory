Q_stat(Q = A, K = 2)
Q_stat(Q = B, K = 2)
Q_stat(Q = rbind(A, c(1,1.1)), K = 2)
Q_stat(Q = rbind(A, c(0,1.1)), K = 2)
rbind(A, c(0,1.1))
Q_stat(Q = rbind(A, c(0,1.1)), K = 2)
Q_stat(Q = A, K = 2)
bs <- Q_bootstrap(matrices = list(A = A, # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
A
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(21, 1, 0.1, 0.1_1,
":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(21, 1, 0.1, "0.1_1", ":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
Q
rbind(A, c(21, 1, 0.1, "0.1_1", ":", 1.1, 0))
rbind(A, c(1, 21, 1, 0.1, "0.1_1", ":", 1.1, 0))
rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D)
if(is.data.frame(matrices) | is.array(matrices)){
n_matrix = 1
names <- "Q"
# Clean Q matrix - isolate ancestry coefficients
matrices <- Q_checker(matrices, K)
bootstrap_matrices_Q <- list()
matrix = matrices
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bootstrap_matrices_Q[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats_Q <- lapply(X = bootstrap_matrices_Q,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-`(c("Fst", "FstMax", "ratio"))
# Do computations if matrices = a list ---------------------------------------------
}else if(is.list(matrices)){
n_matrix = length(matrices)
# List of names of matrices
names <- if(sum(!is.na(names(matrices)))){names(matrices)}else{1:n_matrix}
## For each matrix: ##
for(m in 1:n_matrix){
bs_list <- list()
matrix = matrices[[m]]
# Check format of matrix
matrix <- Q_checker(Q = matrix, K = K, rep = m)
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bs_list[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats <- lapply(X = bs_list,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-` (c("Fst", "FstMax", "ratio"))
# Sometimes, for values of Fst very close to 0 (i.e. order 10^-6, 10^-7), the
# value of Fst ends up negative due to precision errors.
# Find matrices for which this is the case, and replace them and their statistics
while(sum(stats$ratio < 0)){
# Which bootstrap matrices have negative values for Fst/FstMax?
negatives <- which(stats$ratio < 0)
# Replace those bootstrap replicates with new, random bootstrap replicates
bs_list[negatives] <- lapply(X = 1:length(negatives),
FUN = function(x){
matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
})
# Replace the corresponding entries of the statistics matrix
stats[negatives,] <- lapply(X = bs_list[negatives],
FUN = function(matrix){
Q_stat(Q = matrix, K=ncol(matrix))
}) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>% data.frame()
} # repeat this until there are no more errors
# Name this dataset, based on the name of the matrices in the list or the entry number
assign(paste0("stats_", names[m]), stats, pos = -1)
assign(paste0("bootstrap_matrices_", names[m]), bs_list, pos = -1)
}
}else{
stop("Error: The entry `matrices` must be a data frame, matrix, or array, or a list of these objects.")
}
# internal function to check if Q matrices are up to spec
Q_checker <- function(Q, K, rep){
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if(ncol(Q) > K){
Q <- Q[,(ncol(Q)-K+1):ncol(Q)]
}
# check if matrix rows sum to 1
sums <- rowSums(Q)
if(any(sums != 1)){
if(missing(rep)){
warning("At least one Q matrix has rows which do not sum to exactly 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row.")
}else{
warning(paste0("At least one of the rows of Q matrix number ", rep,
" (restricted to the last K columns) does not sum to 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row."))
}
Q <- Q/sums
}
return(Q)
}
if(is.data.frame(matrices) | is.array(matrices)){
n_matrix = 1
names <- "Q"
# Clean Q matrix - isolate ancestry coefficients
matrices <- Q_checker(matrices, K)
bootstrap_matrices_Q <- list()
matrix = matrices
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bootstrap_matrices_Q[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats_Q <- lapply(X = bootstrap_matrices_Q,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-`(c("Fst", "FstMax", "ratio"))
# Do computations if matrices = a list ---------------------------------------------
}else if(is.list(matrices)){
n_matrix = length(matrices)
# List of names of matrices
names <- if(sum(!is.na(names(matrices)))){names(matrices)}else{1:n_matrix}
## For each matrix: ##
for(m in 1:n_matrix){
bs_list <- list()
matrix = matrices[[m]]
# Check format of matrix
matrix <- Q_checker(Q = matrix, K = K, rep = m)
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bs_list[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats <- lapply(X = bs_list,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-` (c("Fst", "FstMax", "ratio"))
# Sometimes, for values of Fst very close to 0 (i.e. order 10^-6, 10^-7), the
# value of Fst ends up negative due to precision errors.
# Find matrices for which this is the case, and replace them and their statistics
while(sum(stats$ratio < 0)){
# Which bootstrap matrices have negative values for Fst/FstMax?
negatives <- which(stats$ratio < 0)
# Replace those bootstrap replicates with new, random bootstrap replicates
bs_list[negatives] <- lapply(X = 1:length(negatives),
FUN = function(x){
matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
})
# Replace the corresponding entries of the statistics matrix
stats[negatives,] <- lapply(X = bs_list[negatives],
FUN = function(matrix){
Q_stat(Q = matrix, K=ncol(matrix))
}) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>% data.frame()
} # repeat this until there are no more errors
# Name this dataset, based on the name of the matrices in the list or the entry number
assign(paste0("stats_", names[m]), stats, pos = -1)
assign(paste0("bootstrap_matrices_", names[m]), bs_list, pos = -1)
}
}else{
stop("Error: The entry `matrices` must be a data frame, matrix, or array, or a list of these objects.")
}
K=2
if(is.data.frame(matrices) | is.array(matrices)){
n_matrix = 1
names <- "Q"
# Clean Q matrix - isolate ancestry coefficients
matrices <- Q_checker(matrices, K)
bootstrap_matrices_Q <- list()
matrix = matrices
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bootstrap_matrices_Q[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats_Q <- lapply(X = bootstrap_matrices_Q,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-`(c("Fst", "FstMax", "ratio"))
# Do computations if matrices = a list ---------------------------------------------
}else if(is.list(matrices)){
n_matrix = length(matrices)
# List of names of matrices
names <- if(sum(!is.na(names(matrices)))){names(matrices)}else{1:n_matrix}
## For each matrix: ##
for(m in 1:n_matrix){
bs_list <- list()
matrix = matrices[[m]]
# Check format of matrix
matrix <- Q_checker(Q = matrix, K = K, rep = m)
# Generate bootstrap data sets
for(replicate in 1:n_replicates){
bs_list[[replicate]] <- matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
}
# Compute statistics for these reps
stats <- lapply(X = bs_list,
FUN = function(matrix) Q_stat(Q = matrix, K=ncol(matrix))) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>%
data.frame() %>%
`colnames<-` (c("Fst", "FstMax", "ratio"))
# Sometimes, for values of Fst very close to 0 (i.e. order 10^-6, 10^-7), the
# value of Fst ends up negative due to precision errors.
# Find matrices for which this is the case, and replace them and their statistics
while(sum(stats$ratio < 0)){
# Which bootstrap matrices have negative values for Fst/FstMax?
negatives <- which(stats$ratio < 0)
# Replace those bootstrap replicates with new, random bootstrap replicates
bs_list[negatives] <- lapply(X = 1:length(negatives),
FUN = function(x){
matrix[purrr::rdunif(n = nrow(matrix),
a = 1, b = nrow(matrix)),]
})
# Replace the corresponding entries of the statistics matrix
stats[negatives,] <- lapply(X = bs_list[negatives],
FUN = function(matrix){
Q_stat(Q = matrix, K=ncol(matrix))
}) %>%
unlist() %>%
matrix(ncol = 3, byrow = TRUE) %>% data.frame()
} # repeat this until there are no more errors
# Name this dataset, based on the name of the matrices in the list or the entry number
assign(paste0("stats_", names[m]), stats, pos = -1)
assign(paste0("bootstrap_matrices_", names[m]), bs_list, pos = -1)
}
}else{
stop("Error: The entry `matrices` must be a data frame, matrix, or array, or a list of these objects.")
}
n_matrix = length(matrices)
# List of names of matrices
names <- if(sum(!is.na(names(matrices)))){names(matrices)}else{1:n_matrix}
m=1
bs_list <- list()
matrix = matrices[[m]]
matrix
# Check format of matrix
matrix <- Q_checker(Q = matrix, K = K, rep = m)
Q
Q = matrix
rep = m
ncol(Q) > K
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if(ncol(Q) > K){
Q <- Q[,(ncol(Q)-K+1):ncol(Q)]
}
Q
# check if matrix rows sum to 1
sums <- rowSums(Q)
str(Q)
# check if matrix rows sum to 1
sums <- rowSums(as.numeric(Q))
as.numeric(Q)
Q
str(Q)
is.numeric(Q)
# convert Q matrix entries to numbers if not already done
Q <- data.matrix(Q)
Q
Q <- A
Q
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if(ncol(Q) > K){
Q <- Q[,(ncol(Q)-K+1):ncol(Q)]
}
Q
data.matrix(Q)
# convert Q matrix entries to numbers if not already done
Q <- data.matrix(Q)
# check if matrix rows sum to 1
sums <- rowSums()
# check if matrix rows sum to 1
sums <- rowSums(Q)
if(any(sums != 1)){
if(missing(rep)){
warning("At least one Q matrix has rows which do not sum to exactly 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row.")
}else{
warning(paste0("At least one of the rows of Q matrix number ", rep,
" (restricted to the last K columns) does not sum to 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row."))
}
Q <- Q/sums
}
# internal function to check if Q matrices are up to spec
Q_checker <- function(Q, K, rep){
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if(ncol(Q) > K){
Q <- Q[,(ncol(Q)-K+1):ncol(Q)]
}
# convert Q matrix entries to numbers if not already done
Q <- data.matrix(Q)
# check if matrix rows sum to 1
sums <- rowSums(Q)
if(any(sums != 1)){
if(missing(rep)){
warning("At least one Q matrix has rows which do not sum to exactly 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row.")
}else{
warning(paste0("At least one of the rows of Q matrix number ", rep,
" (restricted to the last K columns) does not sum to 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row."))
}
Q <- Q/sums
}
return(Q)
}
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
devtools::load_all()
rm(Q_checker)
devtools::load_all()
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)), # name = matrix
B = B,
C = C,
D = D),
n_replicates = 100,
K = 2,
seed = 1)
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)),
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
Q
is.data.frame(matrices)
is.array(matrices)
is.matrix(matrices)
str(matrices)
devtools::load_all()
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
rm(matrices)
rm(matrix)
Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)))
str(matrices)
length(matrices)
length(A)
devtools::load_all()
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
devtools::load_all()
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
Q
matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0)))
n_replicates = 100
K = 2
seed = 1
if(!missing(seed)){set.seed(seed)}
is.data.frame(matrices) | is.array(matrices) | length(matrices)==1
is.data.frame(matrices)
is.array(matrices)
length(matrices)==1
n_matrix = 1
names <- "Q"
matrices
matrices[1]
matrices[[1]]
devtools::load_all
devtools::load_all()
bs <- Q_bootstrap(matrices = list(A = rbind(A, c(1, "21", 0.1, "0.1_1", ":", 1.1, 0))),
n_replicates = 100,
K = 2,
seed = 1)
bs
Q
colMeans(Q)
clustermeans <- colMeans(Q) %>% sort
clustermeans
names(clustermeans)
# Generate the data to plot
df <- data.frame(cbind(data.frame(Individuals =1:nrow(Q)),Q)) %>%
tidyr::pivot_longer(cols = 2:(ncol(Q)+1))
df$name <- factor(df$name, levels = unique(df$name) %>% rev)
df
D = Q_simulate(alpha = 1,
lambda = c(.7, .5),
rep = 1,
popsize = 20,
seed = 4)
D
devtools::load_all()
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100))
Q
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100)), rep = 1)
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100), rep = 1)
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1))
Q
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1), K=3)
Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
Q_plot(Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1), K=3)
Q
Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
K=3
# Check if Q matrix is within a list, and extract if needed
if(is.list(Q)){Q <- Q[[1]]}
Q
is.list(Q)
Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
Q
# Check if Q matrix is within a list, and extract if needed
if(is.list(Q)){Q <- Q[[1]]}
is.list(Q)
Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
# Check if Q matrix is within a list, and extract if needed
if(is.list(Q)==TRUE){Q <- Q[[1]]}
Q = Q_simulate(alpha = 1, lambda = c(.1,.6,.3), popsize = 100, rep = 1)
str(Q)
is.list(Q)
is.dataframe(Q)
is.data.frame(Q)
# Check if Q matrix is within a list, and extract if needed
if(is.list(Q) && !is.data.frame(Q)){Q <- Q[[1]]}
# Check if Q matrix is within a list, and extract if needed
if(is.list(Q) && !is.data.frame(Q) && !is.array(Q)){Q <- Q[[1]]}
# Check if Q matrix is in STRUCTURE/ADMIXTURE output form, or if it only contains columns of ancestry coefficients
# If it is in STRUCTURE/ADMIXTURE output form, extract the ancestry coefficients--the last K columns.
if(ncol(Q) > K){
Q <- Q[,(ncol(Q)-K+1):ncol(Q)]
}
# convert Q matrix entries to numbers
Q <- data.matrix(Q)
# check if matrix rows sum to 1, and give useful warnings if rounding is necessary
sums <- rowSums(Q)
if(any(sums != 1)){
if(missing(rep)){
warning("At least one Q matrix has rows which do not sum to exactly 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row.")
}else{
warning(paste0("At least one of the rows of Q matrix number ", rep,
" (restricted to the last K columns) does not sum to 1. Rounding the sum of each row to 1 by dividing all entries by the sum of the row."))
}
# Normalize each row of the matrix by dividing by the rowsums
Q <- Q/sums
}
sums
any(sums != 1)
sums != 1
Q
# check if matrix rows sum to 1, and give useful warnings if rounding is necessary
sums <- rowSums(Q) %>% round(10)
any(sums != 1)
# check if matrix rows sum to 1, and give useful warnings if rounding is necessary
sums <- rowSums(Q) %>% round(20)
(any(sums != 1)
)
