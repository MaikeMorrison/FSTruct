---
title: "Introduction to FSTruct"
Author: Maike Morrison
Date: 2021-04-28
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fstruct-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warnings = FALSE,
  comment = "#>"
)

library(dplyr)

Q_example <- matrix(
  c(1, "0.001_1", 1, 1, ":", 0.428121, 0.571879, 
    2, "0.001_2", 2, 1, ":", 0.402014, 0.597986, 
    3, "0.001_3", 3, 1, ":", 0.384399, 0.615601, 
    4, "0.001_4", 4, 1, ":", 0.378551, 0.621449, 
    5, "0.001_5", 5, 1, ":", 0.373431, 0.626569, 
    6, "0.001_6", 6, 1, ":", 0.368566, 0.631434, 
    7, "0.001_7", 7, 1, ":", 0.361619, 0.638381, 
    8, "0.001_8", 8, 1, ":", 0.360798, 0.639202, 
    9, "0.001_9", 9, 1, ":", 0.358637, 0.641363, 
    10, "0.001_10", 10, 1, ":", 0.357666, 0.642334
    ),
  ncol = 7, 
  byrow = TRUE
) %>% 
  data.frame %>% 
  mutate(X6 = as.numeric(X6), 
         X7 = as.numeric(X7))

```


The FSTruct package provides an $F_{ST}$-based tool to compare variability among $Q$ matrices (the default output of population structure inference programs such as  [ADMIXTURE](http://dalexander.github.io/admixture/index.html) and [STRUCTURE](https://web.stanford.edu/group/pritchardlab/structure.html)). 

The package includes four functions:

* `Q_stat` calculates $F_{ST}/F_{ST}^{max}$ (a  normalized measure of variability) for a Q matrix.
* `Q_bootstrap` generates bootstrap replicates of one or more Q matrices along with associated statistics, including $F_{ST}/F_{ST}^{max}$, as well as plots and statistical tests to compare bootstrap distributions of $F_{ST}/F_{ST}^{max}$. 
* `Q_plot` plots Q matrices using `ggplot2`.
* `Q_simulate` generates one or more Q matrices.

This package accompanies (insert paper citation here).

## What is a $Q$ matrix?

A $Q$ matrix represents the ancestry of a population; each row represents an individual, while the last $K$ columns contain proportions called membership coefficients (the other columns give details about the individual, like its name and what population it belongs to). Membership coefficients describe how much of an individual's ancestry derives from a given ancestral cluster. An individual's membership coefficients sum to 1.

A $Q$ matrix generated by the program ADMIXTURE with $K=2$ ancestral clusters looks like this:

```{r echo = FALSE}
knitr::kable(Q_example, col.names = NULL)
```

You can see that the last $K=2$ columns contain the membership coefficients. 

## Example Analysis

In the following paragraphs, we discuss how to load or simulate $Q$ matrices, visualize them, analyze their variability, and interpret the results of statistical tests comparing the variability of multiple $Q$ matrices. All of these tasks can be accomplished using the four functions in the package FSTruct. 

### Load or simulate Q matrices

```{r setup}
library(FSTruct)
library(dplyr)
```

To begin your analysis, read your Q matrices into R as data frame objects. You can do this using:
```{r, eval = FALSE}
Q_matrix_name <- data.table::fread("file path to your Q matrix.output")
```
or using your favorite file finagler. 

Alternatively, you can simulate random Q matrices using `Q_simulate`, which draws individuals from a probability distribution called the Dirichlet (for more details on the Dirichlet distribution, see the "Simulation examples" section of *the paper*). For this example, I will simulate four Q matrices, named `A`, `B`, `C`, and `D`, each with 20 individuals. 

All four Q matrices are simulated with the same vector of mean membership coefficients, $\lambda = (.75, .25)$. This means that, on average, individuals possess three-quarters of their ancestry from the first ancestral cluster, and one-quarter of their ancestry from the second ancestral cluster. 

Matrices `A` and `B` are simulated using $\alpha = 0.1$, which will result in fairly high variability across membership coefficients. Properties of the Dirichlet distribution tell us that the variance of the $k^{th}$ ancestral cluster, $x_k$, is $Var[x_k] = \lambda_k/(\alpha+1)$. It follows that, for matrices `A` and `B`, $Var[x_1] = .75/(.1+1) \approx 0.68$ and $Var[x_2] = .25/(.1+1) \approx 0.23$. Matrices `C` and `D` are simulated using $\alpha = 1$, which yields $Var[x_1] = .75/(1+1) = 0.375$ and $Var[x_2] = .25/(1+1) = 0.125$. Higher values of $\alpha$ result in lower variances across membership coefficients.

```{r}
# alpha controls the variability
# lambda controls the mean
# rep is how many matrices to simulate
# popsize is how many individuals to put in the Q matrix
# seed is an optional random seed to make results reproducible

A = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 1)

B = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 2)

C = Q_simulate(alpha = 1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 3)

D = Q_simulate(alpha = 1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 4)
```

Here is what matrix `A` looks like:
```{r, echo = FALSE}
knitr::kable(A)
```

You can see that its format is very similar to the format of the ADMIXTURE Q matrix above. Importantly, the last two columns contain the membership coefficients.

I can visualize these matrices using the function `Q_plot`:

```{r}
cowplot::plot_grid(Q_plot(Q = A, K=2) %>% 
                     arrange(lambda1), 
                   Q_plot(Q = B, K=2) %>% 
                     arrange(lambda1), 
                   Q_plot(Q = C, K=2) %>% 
                     arrange(lambda1), 
                   Q_plot(Q = D, K=2) %>% 
                     arrange(lambda1), 
                   labels = "AUTO", nrow = 1, vjust = 1.5)
```


### Compute $F_{ST}/F_{ST}^{max}$ for each $Q$ matrix

As a preliminary analysis, let's compute $F_{ST}/F_{ST}^{max}$ for each of our four simulated $Q$ matrices.

```{r}
Q_stat(Q = A, K = 2)
Q_stat(Q = B, K = 2)
Q_stat(Q = C, K = 2)
Q_stat(Q = D, K = 2)
```

For each matrix, the function `Q_stat` returns $F_{ST}$, $F_{ST}^{max}$, and their ratio $(F_{ST}/F_{ST}^{max})$. Readers with a population genetics background may be familiar with the statistic $F_{ST}$, which is traditionally used to quantify the variability in allele frequencies among a collection of subpopulations. Here, we use this statistic to quantify the variability in membership coefficients among a collection of subpopulations, which is a mathematically analogous scenario. (See the methods section of *the paper* for a more thorough treatment of this analogy.) Importantly, when the $Q$ matrix contains few individuals, or the membership of the most prevalent ancestral cluster is close to the 0 or 1, the maximum possible value of $F_{ST}$ $(F_{ST}^{max})$ can be much less than 1. For this reason, we use the normalized statistic, $F_{ST}/F_{ST}^{max}$, which always ranges between 0 and 1, and can thus be used to compare the variability of multiple $Q$ matrices. 

We observe from the results of `Q_stat` that matrices `A` and `B` have values of $F_{ST}/F_{ST}^{max}$ greater than 0.8, while matrices `C` and `D` have values close to 0.5. Is the similarity between `C` and `D` the result of random chance? Are the differences in variability between matrices `A` and `B` statistically significant?

To answer these questions, we employ a method called [bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping_(statistics)). 

### Generate & analyze bootstrap distributions of $F_{ST}/F_{ST}^{max}$ for each matrix

A bootstrap replicate of a Q matrix is a second matrix with the same dimensions whose rows were drawn with replacement from those of the original matrix. By generating many bootstrap replicate matrices, and computing $F_{ST}/F_{ST}^{max}$ for each, we generate a bootstrap distribution of $F_{ST}/F_{ST}^{max}$. This bootstrap distribution is an estimate of the sampling distribution (the distribution attained by drawing multiple Q matrices from the full population).

I generate a bootstrap distribution for the four simulated $Q$ matrices with the function `Q_bootstrap`.
```{r}
bs <- Q_bootstrap(matrices = list(A = A, # name = matrix
                                  B = B,
                                  C = C,
                                  D = D), 
      # How many bootstrap replicates for each Q matrix?
                  n_replicates = 100,
      # How many ancestral clusters do the provided Q matrices have?
                  K = 2)
```

The output of `Q_bootstrap`, which I named `bs`, is a list of objects such as:

* `statistics`: A dataframe containing the value of $F_{ST}/F_{ST}^{max}$ for each bootstrap replicate matrix

* `bootstrap_replicates`: A list of a bootstrap replicate matrices for each $Q$ matrix provided

* `plot_boxplot`: A box plot of the bootstrap distribution of $F_{ST}/F_{ST}^{max}$ for each $Q$ matrix

* `test_pairwise_wilcox`: The results of a Wilcoxon rank-sum test, which tests whether each pairwise combination of bootstrap distributions is identical.


