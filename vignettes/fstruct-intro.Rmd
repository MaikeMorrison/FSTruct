---
title: "Introduction to FSTruct"
Author: Maike Morrison
Date: 2021-04-28
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fstruct-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warnings = FALSE,
  message = FALSE,
  fig.width = 7,
  comment = "#>"
)

library(dplyr)

Q_example <- matrix(
  c("1", "1", "(x)", "1", ":", "1", "0", "0", 
    "2", "2", "(x)", "1", ":", "1",  "0", "0",
    "3", "3", "(x)", "2", ":", "0.0137", "0.7567", "0.2296",
    "4", "4", "(x)", "2", ":", "0", "0.7325", "0.2674",
    "5", "5", "(x)", "2", ":", "0.0224", "0.7279", "0.2496",
    "6", "6", "(x)", "3", ":", "0.0222", "0.7372", "0.2406",
    "7", "7", "(x)", "3", ":", "0", "0.7396", "0.2603",
    "8", "8", "(x)", "3", ":", "0.0231", "0.7496", "0.2272",
    "9", "9", "(x)", "3", ":", "0.046", "0.6861", "0.2678",
    "10", "10", "(x)", "3", ":", "0.0843", "0.6739", "0.2418"),
  ncol = 8, 
  byrow = TRUE
) %>% 
  data.frame %>% 
  mutate(X6 = as.numeric(X6), 
         X7 = as.numeric(X7))

```


The FSTruct package provides an $F_{ST}$-based tool to quantify the variability of $Q$ matrices (matrices with row vectors of ancestry coefficients, the default output of population structure inference programs such as  [ADMIXTURE](http://dalexander.github.io/admixture/index.html) and [STRUCTURE](https://web.stanford.edu/group/pritchardlab/structure.html)). 

The package includes four functions:

* `Q_stat` calculates $F_{ST}/F_{ST}^{max}$ (a normalized measure of variability of membership vectors across individuals) for a $Q$ matrix.
* `Q_bootstrap` generates bootstrap replicates of one or more $Q$ matrices along with associated statistics, including $F_{ST}/F_{ST}^{max}$, as well as plots and statistical tests to compare bootstrap distributions of $F_{ST}/F_{ST}^{max}$ for different matrices. 
* `Q_plot` plots $Q$ matrices using `ggplot2`.
* `Q_simulate` generates one or more $Q$ matrices by drawing vectors of membership coefficients (each representing an individual) from the Dirichlet distribution.

This package accompanies a forthcoming paper by Maike Morrison, Nicolas Alcala, and Noah Rosenberg.

### In this document, we walk through an example analysis, including how to:

* **Load or simulate $Q$ matrices**

* **Visualize $Q$ matrices**

* **Calculate the $F_{ST}/F_{ST}^{max}$ variability statistic for each $Q$ matrix**

* **Generate & analyze bootstrap distributions of $F_{ST}/F_{ST}^{max}$ for each matrix**

* **Use statistical tests to compare the variability of multiple $Q$ matrices**

All of these tasks can be accomplished using the four functions in the package FSTruct.

## What is a $Q$ matrix?

A $Q$ matrix represents the ancestry of a population; each row represents an individual and the last $K$ columns contain proportions called membership coefficients (the other columns give details about the individual, such as its name and population identifier). Membership coefficients describe how much of an individual's ancestry derives from a given ancestral cluster. An individual's membership coefficients sum to 1.

A $Q$ matrix generated by the program ADMIXTURE with $K=3$ ancestral clusters looks like this:

```{r echo = FALSE}
knitr::kable(Q_example, col.names = NULL)
```

The last $K=3$ columns contain the membership coefficients. 

## Install and load FSTruct

The FSTruct package can be downloaded from GitHub using the code below. Be sure to first install the package `devtools` if it is not yet installed.

```{r}
# install.packages("devtools") # Run if devtools is not yet installed
# devtools::install_github("MaikeMorrison/FSTruct") # Run if FSTruct is not yet installed
```

To follow along with this vignette, make sure the following packages are also installed:

```{r}
# install.packages("dplyr") # Run if dplyr is not yet installed
# install.packages("ggplot2") # Run if ggplot2 is not yet installed
# install.packages("cowplot") # Run if cowplot is not yet installed
# install.packages("data.table") # Run if data.table is not yet installed
```

Then load the package `FSTruct` and the package `dplyr`, which contains functions such as the pipe `%>%` and the function `arrange`, which reorders the rows of a data frame.

```{r setup}
library(FSTruct)
library(dplyr)
```

## Load or simulate $Q$ matrices

To begin the analysis, read one or more $Q$ matrices into R. For each $Q$ matrix, this task can be accomplished using:
```{r, eval = FALSE}
Q_matrix_name <- data.table::fread("file path to your Q matrix.output")
```
or other functions, such as `read.table()`.

Note that the default column names of these $Q$ matrices will likely be `V1`, `V2`, `V3`, ... If you wish to give the columns more informative names, use the function `colnames`, listing on the right-hand side your desired column names (the example below uses the same names as `Q_simulate` for $K=2$ ancestral clusters):
```{r, eval = FALSE}
colnames(Q_matrix_name) <- c("rep", "ind", "alpha", "Pop", "spacer", "q1", "q2")
```

Repeat this process for each $Q$ matrix you wish to analyze. 

Alternatively, $Q$ matrices can be simulated using `Q_simulate`, which draws individuals from a Dirichlet probability distribution (for more details on the Dirichlet distribution, see the "Simulation examples" section of the forthcoming paper by Morrison, Alcala, and Rosenberg).  

The function `Q_simulate` has four parameters:

* `alpha`, a number that controls the variability. Higher values of $\alpha$ result in lower variances across membership coefficients.

* `lambda`, a vector that controls the mean membership of each ancestral cluster.

* `rep`, the number of matrices to simulate.

* `popsize`, the number of individuals to put in the $Q$ matrix.

* `seed`, an optional random seed to make results reproducible.

For this example, I chose to simulate four $Q$ matrices (`A`, `B`, `C`, and `D`), each with 20 individuals and with the same vector of mean membership coefficients, $\lambda = (.75, .25)$. This means that each $Q$ matrix will have 20 rows and, on average, individuals from any of the four matrices will possess three-quarters of their ancestry from the first ancestral cluster, and one-quarter of their ancestry from the second ancestral cluster. 

I chose to simulate matrices `A` and `B` using $\alpha = 0.1$, which results in fairly high variability across membership coefficients, and matrices `C` and `D` using $\alpha = 5$, which results in lower variability. Properties of the Dirichlet distribution tell us that the variance of the $k^{th}$ ancestral cluster, $q_k$, is $Var[q_k] = \lambda_k(1-\lambda_k)/(\alpha+1)$. It follows that, for matrices `A` and `B`, $Var[q_1] = Var[q_2]=.75\times.25/(.1+1) \approx 0.17$. For matrices `C` and `D`, $Var[q_1] = Var[q_2] = .75\times.25/(5+1) \approx 0.03$. 


```{r}
A = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 1)

B = Q_simulate(alpha = .1, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 2)

C = Q_simulate(alpha = 5, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 3)

D = Q_simulate(alpha = 5, lambda = c(.75, .25), rep = 1, popsize = 20, seed = 4)
```

Here is what matrix `A` looks like:
```{r, echo = FALSE}
knitr::kable(A)
```

The format of this $Q$ matrix is very similar to the format of the ADMIXTURE $Q$ matrix above. The last $K=2$ columns contain the membership coefficients.

## Visualize $Q$ Matrices

We visualize these matrices using the function `Q_plot`, which has two required parameters: a $Q$ matrix (`Q`) and the number of ancestral clusters (`K`). The third parameter, `arrange`, is optional. If `arrange = TRUE`, the individuals' are horizontally ordered by the clusters with the greatest mean membership. Below, we accomplish this ordering manually for plot A, and use `arrange = TRUE` for all subsequent plots. These two methods accomplish the same ordering.

```{r}
# Generate and modify a plot for each Q matrix

plot_A <- Q_plot(Q = A %>% arrange(q1),
                 K=2) + 
  ggplot2::scale_fill_brewer("Blues")

plot_B <- Q_plot(Q = B, 
                 K=2,
                 arrange = TRUE) + 
  ggplot2::scale_fill_brewer("Blues")

plot_C <- Q_plot(Q = C, 
                 K=2,
                 arrange = TRUE) + 
  ggplot2::scale_fill_brewer("Blues")

plot_D <- Q_plot(Q = D, 
                 K=2,
                 arrange = TRUE) + 
  ggplot2::scale_fill_brewer("Blues")
```

`%>%`, the pipe from dplyr, feeds the value on its left-hand side into the function on its right-hand side. 

`arrange(matrix, var)`, a function from dplyr, sorts the rows in `matrix` according to a column named `var`. Here, I order individuals in each $Q$ matrix according to their value of `q1`, but other variables can also be used. Use `colnames(Q_matrix_name)` to see the column names and decide which to sort by. Matrices can also be sorted by multiple columns (e.g., `arrange(matrix, var1, var2)`).

`scale_fill_brewer()`, a function from ggplot2, modifies the color scheme of the plot. Because `Q_plot()` outputs a ggplot object, you can do lots of modifications!

```{r}
# Display these plots in a grid
cowplot::plot_grid(plot_A, plot_B, plot_C, plot_D,
                   labels = "AUTO", 
                   nrow = 1,
                   vjust = 2) 
```


We observe that matrices A and B are visually similar, with most individuals from each matrix possessing all of their ancestry in just one of the two clusters (here, all light blue or all dark blue). For a $Q$ matrix with two ancestral clusters, the maximum variability case occurs when every individual (or all but one) has a membership vector of $(0,1)$ or $(1,0)$ (possessing all of its ancestry in just one of the two clusters).  Matrices A and B are close to this maximum case, as they contain just a few individuals with ancestry in multiple clusters.

Matrices C and D, on the other hand, are comprised of individuals with some ancestry from each cluster. These matrices are closer to the minimum variability case, in which every individual's membership coefficients are the same as the mean (here, 3/4 dark blue and 1/4 light blue). 

We have now built intuition about what high and low variability $Q$ matrices look like. The statistic $F_{ST}/F_{ST}^{max}$ quantifies this variability.

## Calculate the variability of each $Q$ matrix

As a preliminary analysis, let's calculate $F_{ST}/F_{ST}^{max}$ for each of our four simulated $Q$ matrices. We will do this analysis using the function `Q_stat`, which accepts two parameters: a $Q$ matrix (`Q`) and the number of ancestral clusters (`K`).

```{r}
Q_stat(Q = A, K = 2)
Q_stat(Q = B, K = 2)
Q_stat(Q = C, K = 2)
Q_stat(Q = D, K = 2)
```

For each matrix, the function `Q_stat` returns $F_{ST}$, $F_{ST}^{max}$, and their ratio $(F_{ST}/F_{ST}^{max})$. In population genetics, the statistic $F_{ST}$ is conventionally used to quantify variability in allele frequencies among a collection of subpopulations. Here, we use this statistic to quantify the variability in membership coefficients among a collection of individuals. (See the methods section of the forthcoming paper for a more thorough discussion of this analogy.) Importantly, when the $Q$ matrix contains few individuals, or the mean membership of the most prevalent ancestral cluster is close to $1/K$ (the minimum value) or 1 (the maximum value), the maximum possible value of $F_{ST}$ $(F_{ST}^{max})$ can be much less than 1. For this reason, we use the normalized statistic, $F_{ST}/F_{ST}^{max}$, which always ranges between 0 and 1, and can thus be used to compare the variability of multiple $Q$ matrices. 

We observe from the results of `Q_stat` that matrices `A` and `B` have values of $F_{ST}/F_{ST}^{max}$ greater than 0.8, whereas matrices `C` and `D` have values close to 0.12. Is the similarity between `C` and `D` the result of random chance? Are the differences in variability between matrices `A` and `B` statistically significant?

To answer these questions, we employ  [bootstrapping](https://en.wikipedia.org/wiki/Bootstrapping_(statistics)). 

## Generate & analyze bootstrap distributions of $F_{ST}/F_{ST}^{max}$ for each matrix

A bootstrap replicate of a $Q$ matrix is a second matrix with the same dimensions whose rows were drawn with replacement from those of the original matrix. By generating many bootstrap replicate matrices and computing $F_{ST}/F_{ST}^{max}$ for each, we generate a bootstrap distribution of $F_{ST}/F_{ST}^{max}$. This bootstrap distribution is an estimate of the sampling distribution (the distribution obtained by drawing multiple $Q$ matrices from the full population). We can perform statistical tests of identity of the bootstrap means to draw conclusions about whether the original $Q$ matrices have significantly different variabilities.

To generate a bootstrap distribution for the four simulated $Q$ matrices, I used the function `Q_bootstrap`, which has four parameters: 

* `matrices`, a named list of $Q$ matrices to analyze

* `n_replicates`, the number of bootstrap replicates to generate for each $Q$ matrix

* `K`, the number of ancestral clusters. Can also be a vector if the number of ancestral clusters differs among the provided $Q$ matrices.

* `seed`, an optional number which, if included, is used as the random seed to make the random results reproducible


```{r}
bootstrap <- Q_bootstrap(matrices = list(A = A, B = B, C = C, D = D), 
                  n_replicates = 100,
                  K = 2, 
                  seed = 1)
```

The output of `Q_bootstrap`, which I named `bootstrap`, is a list of the following objects:

* `bootstrap_replicates`: A list of bootstrap replicate matrices for each $Q$ matrix provided

* `statistics`: A dataframe containing the values of $F_{ST}$, $F_{ST}^{max}$, and $F_{ST}/F_{ST}^{max}$ for each bootstrap replicate matrix

* `plot_boxplot`, `plot_violin`, `plot_ecdf`: A box plot, violin plot, or empirical cumulative distribution function (ECDF) plot of the bootstrap distribution of $F_{ST}/F_{ST}^{max}$ for each $Q$ matrix

* `test_kruskal_wallis`: The results of a Kruksal-Wallis test, which tests the identity of all provided bootstrap means

* `test_pairwise_wilcox`: The results of a Wilcoxon rank-sum test, which tests the identity of pairwise bootstrap means for each pair of matrices


All three options for visualizing the bootstrap distributions are ggplot objects and can be modified in many ways using tools from the package `ggplot2`:

```{r, fig.height=4}
cowplot::plot_grid(bootstrap$plot_boxplot + ggplot2::ggtitle("Box Plot"), 
                   bootstrap$plot_violin + ggplot2::ggtitle("Violin Plot"), 
                   bootstrap$plot_ecdf + ggplot2::ggtitle("ECDF Plot"), 
                   nrow = 2, rel_widths = c(1,1,2))
```


## Use statistical tests to compare the variability of multiple $Q$ matrices

Comparing these distributions by eye, it seems like the bootstrap distributions of matrices `A` and `B` are each quite different from all of the other matrices. `C` and `D`, on the other hand, seem quite similar to each other. Rather than relying on our intuition, we can statistically test the similarity of these distributions. Included in the output of `Q_bootstrap` are the output of two such tests:

* The Kruskal-Wallis test determines if statistically significant differences exist among a collection of two or more distributions. Its output includes a chi-squared statistic and a p-value.

* The Wilcoxon rank sum test looks at *every pairwise combination of distributions*, and for each determines if a statistically significant difference exists between the two distributions. Its output is a matrix of p-values, one for each pair of distributions.

For both tests, the null hypothesis is that the distributions are the same. 

```{r}
bootstrap$test_kruskal_wallis

bootstrap$test_pairwise_wilcox
```

**The results of these tests support the claim that significant differences exist in the variability of all pairs of matrices except the pair containing matrices `C` and `D`.**

You cannot make comparisons if only one $Q$ matrix is provided. If only one matrix is provided to `Q_bootstrap`, the entries `test_kruskal_wallis` and `test_pairwise_wilcox` will contain the text *"This statistical test can only be performed if a list of matrices is provided."* instead of the results of a statistical test.


## Final Thoughts

This concludes the introduction to the package FSTruct--we hope you found it helpful. For more information, see the forthcoming paper by Maike Morrison, Nicolas Alcala, and Noah Rosenberg. Or, in the R console, type `?FSTruct::Q_...` to read the documentation for particular functions (e.g. `?FSTruct::Q_bootstrap`). 

